"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const z=require("fabric");function O(a){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const e in a)if(e!=="default"){const n=Object.getOwnPropertyDescriptor(a,e);Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>a[e]})}}return t.default=a,Object.freeze(t)}const y=O(z),w=a=>Object.keys(a);function H({canvas:a,horizontalOffset:t=4,verticalOffset:e=4,color:n="purple"}){if(!a)return;let r=a.getWidth(),o=a.getHeight(),i=r/2,s=o/2,d={},p={},f=n,C=1,u=a.getSelectionContext();for(let g=i-t,m=i+t;g<=m;g++)d[Math.round(g)]=!0;for(let g=s-e,m=s+e;g<=m;g++)p[Math.round(g)]=!0;function h(){x(i,0,i,o)}function l(){x(0,s,r,s)}function x(g,m,L,T){const v=a.viewportTransform,W=y.util.transformPoint(new y.Point(g,m),v),b=y.util.transformPoint(new y.Point(L,T),v);u.save(),u.strokeStyle=f,u.lineWidth=C,u.beginPath(),u.moveTo(W.x,W.y),u.lineTo(b.x,b.y),u.stroke(),u.restore()}let c=null,M=null;a.on("mouse:down",()=>{c=null,M=null,a.viewportTransform}),a.on("object:moving",function(g){let m=g.target,L=m.getCenterPoint();a._currentTransform&&(c=Math.round(L.x)in d,M=Math.round(L.y)in p,(M||c)&&m.setPositionByOrigin(new y.Point(c?i:L.x,M?s:L.y),"center","center"))}),a.on("before:render",function(){a.clearContext(a.contextTop)}),a.on("object:modified",function(){c=null,M=null,a.clearContext(a.contextTop),a.renderAll()}),a.on("after:render",()=>{c&&h(),M&&l()}),a.on("mouse:up",function(){a.renderAll()})}class S{aligningLineMargin=4;aligningLineWidth=.75;aligningLineColor="#F68066";verticalOffset=5;horizontalOffset=5;ignoreObjTypes=[];pickObjTypes=[];canvas;ctx;viewportTransform;verticalLines=[];horizontalLines=[];activeObj=new y.Object;constructor({canvas:t,aligningOptions:e,ignoreObjTypes:n,pickObjTypes:r}){this.canvas=t,this.ctx=t.getSelectionContext(),this.ignoreObjTypes=n||[],this.pickObjTypes=r||[],e&&(this.aligningLineMargin=e.lineMargin||this.aligningLineMargin,this.aligningLineWidth=e.lineWidth||this.aligningLineWidth,this.aligningLineColor=e.lineColor||this.aligningLineColor,this.verticalOffset=e.verticalOffset||this.verticalOffset,this.horizontalOffset=e.horizontalOffset||this.horizontalOffset)}drawSign(t,e){const n=this.ctx;n.lineWidth=.5,n.strokeStyle=this.aligningLineColor,n.beginPath();const r=2;n.moveTo(t-r,e-r),n.lineTo(t+r,e+r),n.moveTo(t+r,e-r),n.lineTo(t-r,e+r),n.stroke()}drawLine(t,e,n,r){const o=this.ctx,i=y.util.transformPoint(new y.Point(t,e),this.canvas.viewportTransform),s=y.util.transformPoint(new y.Point(n,r),this.canvas.viewportTransform);o.save(),o.lineWidth=this.aligningLineWidth,o.strokeStyle=this.aligningLineColor,o.beginPath(),o.moveTo(i.x,i.y),o.lineTo(s.x,s.y),o.stroke(),this.drawSign(i.x,i.y),this.drawSign(s.x,s.y),o.restore()}centerObjectInCanvas(){const t={x:this.canvas.getWidth()/2,y:this.canvas.getHeight()/2},e=this.activeObj,n=e.getScaledWidth(),r=e.getScaledHeight();e.set({left:t.x-n/2,top:t.y-r/2}),e.setCoords(),this.canvas.renderAll()}drawVerticalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);w(e).some(n=>Math.abs(e[n].x-t.x)<1e-4)&&this.drawLine(t.x,Math.min(t.y1,t.y2),t.x,Math.max(t.y1,t.y2))}drawHorizontalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);w(e).some(n=>Math.abs(e[n].y-t.y)<1e-4)&&this.drawLine(Math.min(t.x1,t.x2),t.y,Math.max(t.x1,t.x2),t.y)}isInRange(t,e){return Math.abs(Math.round(t)-Math.round(e))<=this.aligningLineMargin/this.canvas.getZoom()}watchMouseDown(){this.canvas.on("mouse:down",()=>{this.clearLinesMeta(),this.viewportTransform=this.canvas.viewportTransform})}watchMouseUp(){this.canvas.on("mouse:up",()=>{this.clearLinesMeta(),this.canvas.renderAll()})}watchMouseWheel(){this.canvas.on("mouse:wheel",()=>{this.clearLinesMeta()})}clearLinesMeta(){this.verticalLines.length=this.horizontalLines.length=0}watchObjectMoving(){this.canvas.on("object:moving",t=>{this.clearLinesMeta();const e=t.target;this.activeObj=e;const n=this.canvas.getObjects().filter(o=>this.ignoreObjTypes.length?!this.ignoreObjTypes.some(i=>o[i.key]===i.value):this.pickObjTypes.length?this.pickObjTypes.some(i=>o[i.key]===i.value):!0);this.canvas._currentTransform&&this.traversAllObjects(e,n)})}getObjDraggingObjCoords(t){const e=t.aCoords,n=new y.Point((e.tl.x+e.br.x)/2,(e.tl.y+e.br.y)/2),r=n.x-t.getCenterPoint().x,o=n.y-t.getCenterPoint().y;return w(e).reduce((i,s)=>({...i,[s]:{x:e[s].x-r,y:e[s].y-o}}),{c:t.getCenterPoint()})}omitCoords(t,e){let n;if(e==="vertical"){let r=["tl",t.tl],o=["tl",t.tl];w(t).forEach(i=>{t[i].x<r[1].x&&(r=[i,t[i]]),t[i].x>o[1].x&&(o=[i,t[i]])}),n={[r[0]]:r[1],[o[0]]:o[1],c:t.c}}else{let r=["tl",t.tl],o=["tl",t.tl];w(t).forEach(i=>{t[i].y<r[1].y&&(r=[i,t[i]]),t[i].y>o[1].y&&(o=[i,t[i]])}),n={[r[0]]:r[1],[o[0]]:o[1],c:t.c}}return n}getObjMaxWidthHeightByCoords(t){const e=Math.max(Math.abs(t.c.y-t.tl.y),Math.abs(t.c.y-t.tr.y))*2,n=Math.max(Math.abs(t.c.x-t.tl.x),Math.abs(t.c.x-t.tr.x))*2;return{objHeight:e,objWidth:n}}calcCenterPointByACoords(t){return new y.Point((t.tl.x+t.br.x)/2,(t.tl.y+t.br.y)/2)}traversAllObjects(t,e){const n=this.getObjDraggingObjCoords(t),r=[],o=[];for(let i=e.length;i--;){if(e[i]===t)continue;const s={...e[i].aCoords,c:e[i].getCenterPoint()},{objHeight:d,objWidth:p}=this.getObjMaxWidthHeightByCoords(s);w(n).forEach(f=>{const C=e[i].angle!==0?this.omitCoords(s,"horizontal"):s;function u(h,l){let x,c;return h==="c"?(x=Math.min(s.c.x-p/2,l[f].x),c=Math.max(s.c.x+p/2,l[f].x)):(x=Math.min(s[h].x,l[f].x),c=Math.max(s[h].x,l[f].x)),{x1:x,x2:c}}w(C).forEach(h=>{if(this.isInRange(n[f].y,s[h].y)){const l=s[h].y;let{x1:x,x2:c}=u(h,n);const M=n[f].y-l;if(o.push(n.c.y-M),t.aCoords){let{x1:g,x2:m}=u(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.horizontalLines.push({y:l,x1:g,x2:m})}else this.horizontalLines.push({y:l,x1:x,x2:c})}})}),w(n).forEach(f=>{const C=e[i].angle!==0?this.omitCoords(s,"vertical"):s;function u(h,l){let x,c;return h==="c"?(x=Math.min(C.c.y-d/2,l[f].y),c=Math.max(C.c.y+d/2,l[f].y)):(x=Math.min(s[h].y,l[f].y),c=Math.max(s[h].y,l[f].y)),{y1:x,y2:c}}w(C).forEach(h=>{if(this.isInRange(n[f].x,s[h].x)){const l=s[h].x;let{y1:x,y2:c}=u(h,n);const M=n[f].x-l;if(r.push(n.c.x-M),t.aCoords){let{y1:g,y2:m}=u(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.verticalLines.push({x:l,y1:g,y2:m})}else this.verticalLines.push({x:l,y1:x,y2:c})}})}),this.snap({activeObject:t,draggingObjCoords:n,snapXPoints:r,snapYPoints:o})}}snap({activeObject:t,snapXPoints:e,draggingObjCoords:n,snapYPoints:r}){const o=(i,s)=>i.length?i.map(d=>({abs:Math.abs(s-d),val:d})).sort((d,p)=>d.abs-p.abs)[0].val:s;t.setPositionByOrigin(new y.Point(o(e,n.c.x),o(r,n.c.y)),"center","center")}clearGuideline(){this.canvas.clearContext(this.ctx)}watchRender(){this.canvas.on("before:render",()=>{this.clearGuideline()}),this.canvas.on("after:render",()=>{for(let t=this.verticalLines.length;t--;)this.drawVerticalLine(this.verticalLines[t]);for(let t=this.horizontalLines.length;t--;)this.drawHorizontalLine(this.horizontalLines[t]);this.canvas.calcOffset()})}init(){this.watchObjectMoving(),this.watchRender(),this.watchMouseDown(),this.watchMouseUp(),this.watchMouseWheel(),this.centerObjectInCanvas(),H({canvas:this.canvas,horizontalOffset:this.horizontalOffset,verticalOffset:this.verticalOffset,color:this.aligningLineColor})}}exports.AlignGuidelines=S;
