"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const C=require("fabric");function T(f){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(f){for(const e in f)if(e!=="default"){const n=Object.getOwnPropertyDescriptor(f,e);Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>f[e]})}}return t.default=f,Object.freeze(t)}const u=T(C),x=f=>Object.keys(f);class v{aligningLineMargin=4;aligningLineWidth=.75;aligningLineColor="#F68066";ignoreObjTypes=[];pickObjTypes=[];canvas;ctx;viewportTransform;verticalLines=[];horizontalLines=[];activeObj=new u.Object;constructor({canvas:t,aligningOptions:e,ignoreObjTypes:n,pickObjTypes:s}){this.canvas=t,this.ctx=t.getSelectionContext(),this.ignoreObjTypes=n||[],this.pickObjTypes=s||[],e&&(this.aligningLineMargin=e.lineMargin||this.aligningLineMargin,this.aligningLineWidth=e.lineWidth||this.aligningLineWidth,this.aligningLineColor=e.lineColor||this.aligningLineColor)}drawSign(t,e){const n=this.ctx;n.lineWidth=.5,n.strokeStyle=this.aligningLineColor,n.beginPath();const s=2;n.moveTo(t-s,e-s),n.lineTo(t+s,e+s),n.moveTo(t+s,e-s),n.lineTo(t-s,e+s),n.stroke()}drawLine(t,e,n,s){const a=this.ctx,i=u.util.transformPoint(new u.Point(t,e),this.canvas.viewportTransform),r=u.util.transformPoint(new u.Point(n,s),this.canvas.viewportTransform);a.save(),a.lineWidth=this.aligningLineWidth,a.strokeStyle=this.aligningLineColor,a.beginPath(),a.moveTo(i.x,i.y),a.lineTo(r.x,r.y),a.stroke(),this.drawSign(i.x,i.y),this.drawSign(r.x,r.y),a.restore()}drawVerticalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);x(e).some(n=>Math.abs(e[n].x-t.x)<1e-4)&&this.drawLine(t.x,Math.min(t.y1,t.y2),t.x,Math.max(t.y1,t.y2))}drawHorizontalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);x(e).some(n=>Math.abs(e[n].y-t.y)<1e-4)&&this.drawLine(Math.min(t.x1,t.x2),t.y,Math.max(t.x1,t.x2),t.y)}isInRange(t,e){return Math.abs(Math.round(t)-Math.round(e))<=this.aligningLineMargin/this.canvas.getZoom()}watchMouseDown(){this.canvas.on("mouse:down",()=>{this.clearLinesMeta(),this.viewportTransform=this.canvas.viewportTransform})}watchMouseUp(){this.canvas.on("mouse:up",()=>{this.clearLinesMeta(),this.canvas.renderAll()})}watchMouseWheel(){this.canvas.on("mouse:wheel",()=>{this.clearLinesMeta()})}clearLinesMeta(){this.verticalLines.length=this.horizontalLines.length=0}watchObjectMoving(){this.canvas.on("object:moving",t=>{this.clearLinesMeta();const e=t.target;this.activeObj=e;const n=this.canvas.getObjects().filter(a=>this.ignoreObjTypes.length?!this.ignoreObjTypes.some(i=>a[i.key]===i.value):this.pickObjTypes.length?this.pickObjTypes.some(i=>a[i.key]===i.value):!0);this.canvas._currentTransform&&this.traversAllObjects(e,n)})}getObjDraggingObjCoords(t){const e=t.aCoords,n=new u.Point((e.tl.x+e.br.x)/2,(e.tl.y+e.br.y)/2),s=n.x-t.getCenterPoint().x,a=n.y-t.getCenterPoint().y;return x(e).reduce((i,r)=>({...i,[r]:{x:e[r].x-s,y:e[r].y-a}}),{c:t.getCenterPoint()})}omitCoords(t,e){let n;if(e==="vertical"){let s=["tl",t.tl],a=["tl",t.tl];x(t).forEach(i=>{t[i].x<s[1].x&&(s=[i,t[i]]),t[i].x>a[1].x&&(a=[i,t[i]])}),n={[s[0]]:s[1],[a[0]]:a[1],c:t.c}}else{let s=["tl",t.tl],a=["tl",t.tl];x(t).forEach(i=>{t[i].y<s[1].y&&(s=[i,t[i]]),t[i].y>a[1].y&&(a=[i,t[i]])}),n={[s[0]]:s[1],[a[0]]:a[1],c:t.c}}return n}getObjMaxWidthHeightByCoords(t){const e=Math.max(Math.abs(t.c.y-t.tl.y),Math.abs(t.c.y-t.tr.y))*2,n=Math.max(Math.abs(t.c.x-t.tl.x),Math.abs(t.c.x-t.tr.x))*2;return{objHeight:e,objWidth:n}}calcCenterPointByACoords(t){return new u.Point((t.tl.x+t.br.x)/2,(t.tl.y+t.br.y)/2)}traversAllObjects(t,e){const n=this.getObjDraggingObjCoords(t),s=[],a=[];for(let i=e.length;i--;){if(e[i]===t)continue;const r={...e[i].aCoords,c:e[i].getCenterPoint()},{objHeight:y,objWidth:w}=this.getObjMaxWidthHeightByCoords(r);x(n).forEach(o=>{const M=e[i].angle!==0?this.omitCoords(r,"horizontal"):r;function m(h,l){let c,g;return h==="c"?(c=Math.min(r.c.x-w/2,l[o].x),g=Math.max(r.c.x+w/2,l[o].x)):(c=Math.min(r[h].x,l[o].x),g=Math.max(r[h].x,l[o].x)),{x1:c,x2:g}}x(M).forEach(h=>{if(this.isInRange(n[o].y,r[h].y)){const l=r[h].y;let{x1:c,x2:g}=m(h,n);const L=n[o].y-l;if(a.push(n.c.y-L),t.aCoords){let{x1:p,x2:d}=m(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.horizontalLines.push({y:l,x1:p,x2:d})}else this.horizontalLines.push({y:l,x1:c,x2:g})}})}),x(n).forEach(o=>{const M=e[i].angle!==0?this.omitCoords(r,"vertical"):r;function m(h,l){let c,g;return h==="c"?(c=Math.min(M.c.y-y/2,l[o].y),g=Math.max(M.c.y+y/2,l[o].y)):(c=Math.min(r[h].y,l[o].y),g=Math.max(r[h].y,l[o].y)),{y1:c,y2:g}}x(M).forEach(h=>{if(this.isInRange(n[o].x,r[h].x)){const l=r[h].x;let{y1:c,y2:g}=m(h,n);const L=n[o].x-l;if(s.push(n.c.x-L),t.aCoords){let{y1:p,y2:d}=m(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.verticalLines.push({x:l,y1:p,y2:d})}else this.verticalLines.push({x:l,y1:c,y2:g})}})}),this.snap({activeObject:t,draggingObjCoords:n,snapXPoints:s,snapYPoints:a})}}snap({activeObject:t,snapXPoints:e,draggingObjCoords:n,snapYPoints:s}){const a=(i,r)=>i.length?i.map(y=>({abs:Math.abs(r-y),val:y})).sort((y,w)=>y.abs-w.abs)[0].val:r;t.setPositionByOrigin(new u.Point(a(e,n.c.x),a(s,n.c.y)),"center","center")}clearGuideline(){this.canvas.clearContext(this.ctx)}watchRender(){this.canvas.on("before:render",()=>{this.clearGuideline()}),this.canvas.on("after:render",()=>{for(let t=this.verticalLines.length;t--;)this.drawVerticalLine(this.verticalLines[t]);for(let t=this.horizontalLines.length;t--;)this.drawHorizontalLine(this.horizontalLines[t]);this.canvas.calcOffset()})}init(){this.watchObjectMoving(),this.watchRender(),this.watchMouseDown(),this.watchMouseUp(),this.watchMouseWheel()}}exports.AlignGuidelines=v;
