(function(y,m){typeof exports=="object"&&typeof module<"u"?m(exports,require("fabric")):typeof define=="function"&&define.amd?define(["exports","fabric"],m):(y=typeof globalThis<"u"?globalThis:y||self,m(y["fabric-guideline"]={},y.fabric))})(this,function(y,m){"use strict";function v(c){if(c&&c.__esModule)return c;const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(c){for(const e in c)if(e!=="default"){const n=Object.getOwnPropertyDescriptor(c,e);Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>c[e]})}}return t.default=c,Object.freeze(t)}const x=v(m),u=c=>Object.keys(c);class W{aligningLineMargin=4;aligningLineWidth=.75;aligningLineColor="#F68066";ignoreObjTypes=[];pickObjTypes=[];canvas;ctx;viewportTransform;verticalLines=[];horizontalLines=[];activeObj=new x.Object;constructor({canvas:t,aligningOptions:e,ignoreObjTypes:n,pickObjTypes:s}){this.canvas=t,this.ctx=t.getSelectionContext(),this.ignoreObjTypes=n||[],this.pickObjTypes=s||[],e&&(this.aligningLineMargin=e.lineMargin||this.aligningLineMargin,this.aligningLineWidth=e.lineWidth||this.aligningLineWidth,this.aligningLineColor=e.lineColor||this.aligningLineColor)}drawSign(t,e){const n=this.ctx;n.lineWidth=.5,n.strokeStyle=this.aligningLineColor,n.beginPath();const s=2;n.moveTo(t-s,e-s),n.lineTo(t+s,e+s),n.moveTo(t+s,e-s),n.lineTo(t-s,e+s),n.stroke()}drawLine(t,e,n,s){const r=this.ctx,i=x.util.transformPoint(new x.Point(t,e),this.canvas.viewportTransform),a=x.util.transformPoint(new x.Point(n,s),this.canvas.viewportTransform);r.save(),r.lineWidth=this.aligningLineWidth,r.strokeStyle=this.aligningLineColor,r.beginPath(),r.moveTo(i.x,i.y),r.lineTo(a.x,a.y),r.stroke(),this.drawSign(i.x,i.y),this.drawSign(a.x,a.y),r.restore()}drawVerticalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);!u(e).some(n=>Math.abs(e[n].x-t.x)<1e-4)||this.drawLine(t.x,Math.min(t.y1,t.y2),t.x,Math.max(t.y1,t.y2))}drawHorizontalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);!u(e).some(n=>Math.abs(e[n].y-t.y)<1e-4)||this.drawLine(Math.min(t.x1,t.x2),t.y,Math.max(t.x1,t.x2),t.y)}isInRange(t,e){return Math.abs(Math.round(t)-Math.round(e))<=this.aligningLineMargin/this.canvas.getZoom()}watchMouseDown(){this.canvas.on("mouse:down",()=>{this.clearLinesMeta(),this.viewportTransform=this.canvas.viewportTransform})}watchMouseUp(){this.canvas.on("mouse:up",()=>{this.clearLinesMeta(),this.canvas.renderAll()})}watchMouseWheel(){this.canvas.on("mouse:wheel",()=>{this.clearLinesMeta()})}clearLinesMeta(){this.verticalLines.length=this.horizontalLines.length=0}watchObjectMoving(){this.canvas.on("object:moving",t=>{this.clearLinesMeta();const e=t.target;this.activeObj=e;const n=this.canvas.getObjects().filter(r=>this.ignoreObjTypes.length?!this.ignoreObjTypes.some(i=>r[i.key]===i.value):this.pickObjTypes.length?this.pickObjTypes.some(i=>r[i.key]===i.value):!0);!this.canvas._currentTransform||this.traversAllObjects(e,n)})}getObjDraggingObjCoords(t){const e=t.aCoords,n=new x.Point((e.tl.x+e.br.x)/2,(e.tl.y+e.br.y)/2),s=n.x-t.getCenterPoint().x,r=n.y-t.getCenterPoint().y;return u(e).reduce((i,a)=>({...i,[a]:{x:e[a].x-s,y:e[a].y-r}}),{c:t.getCenterPoint()})}omitCoords(t,e){let n;if(e==="vertical"){let s=["tl",t.tl],r=["tl",t.tl];u(t).forEach(i=>{t[i].x<s[1].x&&(s=[i,t[i]]),t[i].x>r[1].x&&(r=[i,t[i]])}),n={[s[0]]:s[1],[r[0]]:r[1],c:t.c}}else{let s=["tl",t.tl],r=["tl",t.tl];u(t).forEach(i=>{t[i].y<s[1].y&&(s=[i,t[i]]),t[i].y>r[1].y&&(r=[i,t[i]])}),n={[s[0]]:s[1],[r[0]]:r[1],c:t.c}}return n}getObjMaxWidthHeightByCoords(t){const e=Math.max(Math.abs(t.c.y-t.tl.y),Math.abs(t.c.y-t.tr.y))*2,n=Math.max(Math.abs(t.c.x-t.tl.x),Math.abs(t.c.x-t.tr.x))*2;return{objHeight:e,objWidth:n}}calcCenterPointByACoords(t){return new x.Point((t.tl.x+t.br.x)/2,(t.tl.y+t.br.y)/2)}traversAllObjects(t,e){const n=this.getObjDraggingObjCoords(t),s=[],r=[];for(let i=e.length;i--;){if(e[i]===t)continue;const a={...e[i].aCoords,c:e[i].getCenterPoint()},{objHeight:M,objWidth:w}=this.getObjMaxWidthHeightByCoords(a);u(n).forEach(o=>{const p=e[i].angle!==0?this.omitCoords(a,"horizontal"):a;function d(h,l){let g,f;return h==="c"?(g=Math.min(a.c.x-w/2,l[o].x),f=Math.max(a.c.x+w/2,l[o].x)):(g=Math.min(a[h].x,l[o].x),f=Math.max(a[h].x,l[o].x)),{x1:g,x2:f}}u(p).forEach(h=>{if(this.isInRange(n[o].y,a[h].y)){const l=a[h].y;let{x1:g,x2:f}=d(h,n);const L=n[o].y-l;if(r.push(n.c.y-L),t.aCoords){let{x1:C,x2:T}=d(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.horizontalLines.push({y:l,x1:C,x2:T})}else this.horizontalLines.push({y:l,x1:g,x2:f})}})}),u(n).forEach(o=>{const p=e[i].angle!==0?this.omitCoords(a,"vertical"):a;function d(h,l){let g,f;return h==="c"?(g=Math.min(p.c.y-M/2,l[o].y),f=Math.max(p.c.y+M/2,l[o].y)):(g=Math.min(a[h].y,l[o].y),f=Math.max(a[h].y,l[o].y)),{y1:g,y2:f}}u(p).forEach(h=>{if(this.isInRange(n[o].x,a[h].x)){const l=a[h].x;let{y1:g,y2:f}=d(h,n);const L=n[o].x-l;if(s.push(n.c.x-L),t.aCoords){let{y1:C,y2:T}=d(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.verticalLines.push({x:l,y1:C,y2:T})}else this.verticalLines.push({x:l,y1:g,y2:f})}})}),this.snap({activeObject:t,draggingObjCoords:n,snapXPoints:s,snapYPoints:r})}}snap({activeObject:t,snapXPoints:e,draggingObjCoords:n,snapYPoints:s}){const r=(i,a)=>i.length?i.map(M=>({abs:Math.abs(a-M),val:M})).sort((M,w)=>M.abs-w.abs)[0].val:a;t.setPositionByOrigin(new x.Point(r(e,n.c.x),r(s,n.c.y)),"center","center")}clearGuideline(){this.canvas.clearContext(this.ctx)}watchRender(){this.canvas.on("before:render",()=>{this.clearGuideline()}),this.canvas.on("after:render",()=>{for(let t=this.verticalLines.length;t--;)this.drawVerticalLine(this.verticalLines[t]);for(let t=this.horizontalLines.length;t--;)this.drawHorizontalLine(this.horizontalLines[t]);this.canvas.calcOffset()})}init(){this.watchObjectMoving(),this.watchRender(),this.watchMouseDown(),this.watchMouseUp(),this.watchMouseWheel()}}y.AlignGuidelines=W,Object.defineProperties(y,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
