(function(y,M){typeof exports=="object"&&typeof module<"u"?M(exports,require("fabric")):typeof define=="function"&&define.amd?define(["exports","fabric"],M):(y=typeof globalThis<"u"?globalThis:y||self,M(y["fabric-guideline"]={},y.fabric))})(this,function(y,M){"use strict";function v(x){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(x){for(const e in x)if(e!=="default"){const n=Object.getOwnPropertyDescriptor(x,e);Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>x[e]})}}return t.default=x,Object.freeze(t)}const u=v(M),f=x=>Object.keys(x);class W{aligningLineMargin=4;aligningLineWidth=.75;aligningLineColor="#F68066";ignoreObjTypes=[];pickObjTypes=[];canvas;ctx;viewportTransform;verticalLines=[];horizontalLines=[];activeObj=new u.Object;constructor({canvas:t,aligningOptions:e,ignoreObjTypes:n,pickObjTypes:s}){this.canvas=t,this.ctx=t.getSelectionContext(),this.ignoreObjTypes=n||[],this.pickObjTypes=s||[],e&&(this.aligningLineMargin=e.lineMargin||this.aligningLineMargin,this.aligningLineWidth=e.lineWidth||this.aligningLineWidth,this.aligningLineColor=e.lineColor||this.aligningLineColor)}drawSign(t,e){const n=this.ctx;n.lineWidth=.5,n.strokeStyle=this.aligningLineColor,n.beginPath();const s=2;n.moveTo(t-s,e-s),n.lineTo(t+s,e+s),n.moveTo(t+s,e-s),n.lineTo(t-s,e+s),n.stroke()}drawLine(t,e,n,s){const a=this.ctx,i=u.util.transformPoint(new u.Point(t,e),this.canvas.viewportTransform),r=u.util.transformPoint(new u.Point(n,s),this.canvas.viewportTransform);a.save(),a.lineWidth=this.aligningLineWidth,a.strokeStyle=this.aligningLineColor,a.beginPath(),a.moveTo(i.x,i.y),a.lineTo(r.x,r.y),a.stroke(),this.drawSign(i.x,i.y),this.drawSign(r.x,r.y),a.restore()}drawVerticalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);f(e).some(n=>Math.abs(e[n].x-t.x)<1e-4)&&this.drawLine(t.x,Math.min(t.y1,t.y2),t.x,Math.max(t.y1,t.y2))}drawHorizontalLine(t){const e=this.getObjDraggingObjCoords(this.activeObj);f(e).some(n=>Math.abs(e[n].y-t.y)<1e-4)&&this.drawLine(Math.min(t.x1,t.x2),t.y,Math.max(t.x1,t.x2),t.y)}isInRange(t,e){return Math.abs(Math.round(t)-Math.round(e))<=this.aligningLineMargin/this.canvas.getZoom()}watchMouseDown(){this.canvas.on("mouse:down",()=>{this.clearLinesMeta(),this.viewportTransform=this.canvas.viewportTransform})}watchMouseUp(){this.canvas.on("mouse:up",()=>{this.clearLinesMeta(),this.canvas.renderAll()})}watchMouseWheel(){this.canvas.on("mouse:wheel",()=>{this.clearLinesMeta()})}clearLinesMeta(){this.verticalLines.length=this.horizontalLines.length=0}watchObjectMoving(){this.canvas.on("object:moving",t=>{this.clearLinesMeta();const e=t.target;this.activeObj=e;const n=this.canvas.getObjects().filter(a=>this.ignoreObjTypes.length?!this.ignoreObjTypes.some(i=>a[i.key]===i.value):this.pickObjTypes.length?this.pickObjTypes.some(i=>a[i.key]===i.value):!0);this.canvas._currentTransform&&this.traversAllObjects(e,n)})}getObjDraggingObjCoords(t){const e=t.aCoords,n=new u.Point((e.tl.x+e.br.x)/2,(e.tl.y+e.br.y)/2),s=n.x-t.getCenterPoint().x,a=n.y-t.getCenterPoint().y;return f(e).reduce((i,r)=>({...i,[r]:{x:e[r].x-s,y:e[r].y-a}}),{c:t.getCenterPoint()})}omitCoords(t,e){let n;if(e==="vertical"){let s=["tl",t.tl],a=["tl",t.tl];f(t).forEach(i=>{t[i].x<s[1].x&&(s=[i,t[i]]),t[i].x>a[1].x&&(a=[i,t[i]])}),n={[s[0]]:s[1],[a[0]]:a[1],c:t.c}}else{let s=["tl",t.tl],a=["tl",t.tl];f(t).forEach(i=>{t[i].y<s[1].y&&(s=[i,t[i]]),t[i].y>a[1].y&&(a=[i,t[i]])}),n={[s[0]]:s[1],[a[0]]:a[1],c:t.c}}return n}getObjMaxWidthHeightByCoords(t){const e=Math.max(Math.abs(t.c.y-t.tl.y),Math.abs(t.c.y-t.tr.y))*2,n=Math.max(Math.abs(t.c.x-t.tl.x),Math.abs(t.c.x-t.tr.x))*2;return{objHeight:e,objWidth:n}}calcCenterPointByACoords(t){return new u.Point((t.tl.x+t.br.x)/2,(t.tl.y+t.br.y)/2)}traversAllObjects(t,e){const n=this.getObjDraggingObjCoords(t),s=[],a=[];for(let i=e.length;i--;){if(e[i]===t)continue;const r={...e[i].aCoords,c:e[i].getCenterPoint()},{objHeight:m,objWidth:L}=this.getObjMaxWidthHeightByCoords(r);f(n).forEach(o=>{const p=e[i].angle!==0?this.omitCoords(r,"horizontal"):r;function w(h,l){let c,g;return h==="c"?(c=Math.min(r.c.x-L/2,l[o].x),g=Math.max(r.c.x+L/2,l[o].x)):(c=Math.min(r[h].x,l[o].x),g=Math.max(r[h].x,l[o].x)),{x1:c,x2:g}}f(p).forEach(h=>{if(this.isInRange(n[o].y,r[h].y)){const l=r[h].y;let{x1:c,x2:g}=w(h,n);const d=n[o].y-l;if(a.push(n.c.y-d),t.aCoords){let{x1:C,x2:T}=w(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.horizontalLines.push({y:l,x1:C,x2:T})}else this.horizontalLines.push({y:l,x1:c,x2:g})}})}),f(n).forEach(o=>{const p=e[i].angle!==0?this.omitCoords(r,"vertical"):r;function w(h,l){let c,g;return h==="c"?(c=Math.min(p.c.y-m/2,l[o].y),g=Math.max(p.c.y+m/2,l[o].y)):(c=Math.min(r[h].y,l[o].y),g=Math.max(r[h].y,l[o].y)),{y1:c,y2:g}}f(p).forEach(h=>{if(this.isInRange(n[o].x,r[h].x)){const l=r[h].x;let{y1:c,y2:g}=w(h,n);const d=n[o].x-l;if(s.push(n.c.x-d),t.aCoords){let{y1:C,y2:T}=w(h,{...t.aCoords,c:this.calcCenterPointByACoords(t.aCoords)});this.verticalLines.push({x:l,y1:C,y2:T})}else this.verticalLines.push({x:l,y1:c,y2:g})}})}),this.snap({activeObject:t,draggingObjCoords:n,snapXPoints:s,snapYPoints:a})}}snap({activeObject:t,snapXPoints:e,draggingObjCoords:n,snapYPoints:s}){const a=(i,r)=>i.length?i.map(m=>({abs:Math.abs(r-m),val:m})).sort((m,L)=>m.abs-L.abs)[0].val:r;t.setPositionByOrigin(new u.Point(a(e,n.c.x),a(s,n.c.y)),"center","center")}clearGuideline(){this.canvas.clearContext(this.ctx)}watchRender(){this.canvas.on("before:render",()=>{this.clearGuideline()}),this.canvas.on("after:render",()=>{for(let t=this.verticalLines.length;t--;)this.drawVerticalLine(this.verticalLines[t]);for(let t=this.horizontalLines.length;t--;)this.drawHorizontalLine(this.horizontalLines[t]);this.canvas.calcOffset()})}init(){this.watchObjectMoving(),this.watchRender(),this.watchMouseDown(),this.watchMouseUp(),this.watchMouseWheel()}}y.AlignGuidelines=W,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});
